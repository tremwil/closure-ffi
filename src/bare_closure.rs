//! Provides the [`BareFnOnce`], [`BareFnMut`] and [`BareFn`] wrapper types which allow closures to
//! be called through context-free unsafe bare functions.

use core::{marker::PhantomData, mem::ManuallyDrop};

#[cfg(feature = "proc_macros")]
#[doc(hidden)]
pub use closure_ffi_proc_macros::bare_hrtb as bare_hrtb_impl;

#[cfg(any(feature = "bundled_jit_alloc", feature = "custom_jit_alloc"))]
use crate::jit_alloc::GlobalJitAlloc;
#[allow(unused_imports)]
use crate::{
    arch::{create_thunk, ThunkInfo},
    cc,
    jit_alloc::{JitAlloc, JitAllocError},
    traits::{Any, FnMutThunk, FnOnceThunk, FnPtr, FnThunk, ToBoxedUnsize},
    Box,
};

/// Declares a wrapper type around a higher-ranked bare function which can be used with [BareFn] and
/// friends.
///
/// The syntax is equivalent to that of a type alias:
/// ```
/// closure_ffi::bare_hrtb! {
///     type MyFn = for<'a> extern "C" fn(&'a str) -> &'a u32;
/// }
/// ```
///
/// Generic type parameters and bounds can be added to the alias. `unsafe` is automatically
/// added to the function signature if absent from the alias.
///
/// Higher-ranked bare functions are not automatically supported by `closure-ffi` as
/// - It is not possible to blanket implement traits for them;
/// - Even if it was possible, type inference via closure annotations would become impossible when
///   references are involved.
///
/// For this reason, the following won't compile:
///
/// ```compile_fail
/// use closure_ffi::BareFn;
///
/// fn take_higher_rank_fn(
///     bare_fn: unsafe extern "C" fn(&Option<u32>) -> Option<&u32>
/// ) {}
///
/// let bare_closure = BareFn::new_c(|opt: &Option<u32>| opt.as_ref());
/// take_higher_rank_fn(bare_closure.bare());
/// ```
///
/// However, using the type generated by this macro as the bare function type, we can get it to
/// work:
///
/// ```
/// use closure_ffi::BareFn;
///
/// closure_ffi::bare_hrtb! {
///     type MyFn = for<'a> extern "C" fn(&'a Option<u32>) -> Option<&'a u32>;
/// }
///
/// fn take_higher_rank_fn(
///     bare_fn: unsafe extern "C" fn(&Option<u32>) -> Option<&u32>
/// ) {}
///
/// let bare_closure = BareFn::<MyFn>::new(|opt| opt.as_ref());
/// take_higher_rank_fn(bare_closure.bare().into());
/// ```
///
/// # Limitations
///
/// Higher-ranked bare functions with more than 3 independent bound lifetimes are not supported. For
/// example, the following will not compile:
///
/// ```compile_fail
/// closure_ffi::bare_hrtb! {
///     type MyFn = extern "C" fn(&Option<u32>) -> Option<&u32>;
/// }
/// ```
#[cfg(feature = "proc_macros")]
#[macro_export]
macro_rules! bare_hrtb {
    ($($tokens:tt)*) => {
        $crate::bare_closure::bare_hrtb_impl! { $crate, $($tokens)* }
    };
}

#[cfg(feature = "proc_macros")]
pub use bare_hrtb;

#[allow(unused_macros)]
macro_rules! cc_shorthand {
    ($fn_name:ident, $trait_ident:ident, $cc_ty:ty, $cc_name:literal $(,$cfg:meta)?) => {
        $(#[cfg(any($cfg, doc))])?
        #[doc = "Create a bare function thunk using the "]
        #[doc = $cc_name]
        #[doc = "calling convention for `fun`."]
        ///
        /// The W^X memory required is allocated using the global JIT allocator.
        #[inline]
        pub fn $fn_name<F>(fun: F) -> Self
        where
            F: ToBoxedUnsize<S>,
            ($cc_ty, F): $trait_ident<B>,
        {
            Self::with_cc(<$cc_ty>::default(), fun)
        }
    };
}

macro_rules! cc_shorthand_in {
    ($fn_name:ident, $trait_ident:ident, $cc_ty:ty, $cc_name:literal $(,$cfg:meta)?) => {
        $(#[cfg(any($cfg, doc))])?
        #[doc = "Create a bare function thunk using the "]
        #[doc = $cc_name]
        #[doc = "calling convention for `fun`."]
        ///
        /// The W^X memory required is allocated using the provided JIT allocator.
        #[inline]
        pub fn $fn_name<F>(fun: F, jit_alloc: A) -> Self
        where
            F: ToBoxedUnsize<S>,
            ($cc_ty, F): $trait_ident<B>,
        {
            Self::with_cc_in(<$cc_ty>::default(), fun, jit_alloc)
        }
    };
}

macro_rules! bare_closure_impl {
    (
        ty_name: $ty_name:ident,
        non_send_alias: $non_send_alias:ident,
        send_alias: $send_alias:ident,
        trait_ident: $trait_ident:ident,
        thunk_template: $thunk_template:ident,
        bare_toggle: $bare_toggle:meta,
        bare_receiver: $bare_receiver:ty,
        fn_trait_doc: $fn_trait_doc:literal,
        ty_name_doc: $ty_name_doc:literal,
        with_cc_doc: $with_cc_doc:literal,
        with_cc_in_doc: $with_cc_in_doc:literal,
        try_with_cc_in_doc: $try_with_cc_in_doc:literal,
        non_send_alias_doc: $non_send_alias_doc:literal,
        send_alias_doc: $send_alias_doc:literal,
        safety_doc: $safety_doc:literal
    ) => {
        #[cfg(any(feature = "bundled_jit_alloc", feature = "custom_jit_alloc"))]
        #[cfg_attr(docsrs, doc(cfg(all())))]
        /// Wrapper around a
        #[doc = $fn_trait_doc]
        /// closure which exposes a bare function thunk that can invoke it without
        /// additional arguments.
        ///
        /// # Note
        /// This is a generic implementation which allows customizing the closure's
        /// type erased storage, which allows enforcing trait bounds like `Send` and `Sync` when
        /// needed. However, this plays poorly with type inference. Consider using the
        #[doc = $non_send_alias_doc]
        /// and
        #[doc = $send_alias_doc]
        /// type aliases for the common cases of `S = dyn Any + 'a` and `S = dyn Send + 'a`.
        ///
        /// # Type parameters
        /// - `B`: The bare function pointer to expose the closure as. For higher-kinded bare
        ///   function pointers, you will need to use the [`bare_hrtb`] macro to define a wrapper
        ///   type.
        /// - `S`: The dynamically-sized type to use to type-erase the closure. By default, this is
        ///   [`dyn Any`](Any) which is implemented by all `'static` types.
        /// - `A`: The [`JitAlloc`] implementation used to allocate and free executable memory.
        #[allow(dead_code)]
        pub struct $ty_name<B: FnPtr, S: ?Sized, A: JitAlloc = GlobalJitAlloc> {
            thunk_info: ThunkInfo,
            jit_alloc: A,
            // We can't directly own the closure, even through an UnsafeCell.
            // Otherwise, holding a reference to a BareFnMut while the bare function is
            // being called would be UB! So we reclaim the pointer in the Drop impl.
            storage: *mut S,
            phantom: PhantomData<B>,
        }

        // We copy the documentation to this type, since IDEs will often fetch it from here for
        // pop-up documentation of neither feature is on
        #[cfg(not(any(feature = "bundled_jit_alloc", feature = "custom_jit_alloc")))]
        /// Wrapper around a
        #[doc = $fn_trait_doc]
        /// closure which exposes a bare function thunk that can invoke it without
        /// additional arguments.
        ///
        /// # Note
        /// This is a generic implementation which allows customizing the closure's
        /// type erased storage, which allows enforcing trait bounds like `Send` and `Sync` when
        /// needed. However, this plays poorly with type inference. Consider using the
        #[doc = $non_send_alias_doc]
        /// and
        #[doc = $send_alias_doc]
        /// type aliases for the common cases of `S = dyn Any + 'a` and `S = dyn Send + 'a`.
        ///
        /// # Type parameters
        /// - `B`: The bare function pointer to expose the closure as. For higher-kinded bare
        ///   function pointers, you will need to use the [`bare_hrtb`] macro to define a wrapper
        ///   type.
        /// - `S`: The dynamically-sized type to use to type-erase the closure. By default, this is
        ///   [`dyn Any`](Any) which is implemented by all `'static` types.
        /// - `A`: The [`JitAlloc`] implementation used to allocate and free executable memory.
        #[allow(dead_code)]
        pub struct $ty_name<B: FnPtr, S: ?Sized, A: JitAlloc> {
            thunk_info: ThunkInfo,
            jit_alloc: A,
            storage: *mut S,
            phantom: PhantomData<B>,
        }

        // SAFETY: S and A can be moved to other threads
        unsafe impl<B: FnPtr, S: ?Sized + Send, A: JitAlloc + Send> Send for $ty_name<B, S, A> {}
        // SAFETY: The references to S and A cannot be accessed given a &Self
        unsafe impl<B: FnPtr, S: ?Sized, A: JitAlloc> Sync for $ty_name<B, S, A> {}

        impl<B: FnPtr, S: ?Sized, A: JitAlloc> $ty_name<B, S, A> {
            /// Wraps `fun`, producing a bare function with calling convention `cconv`.
            ///
            /// Uses the provided JIT allocator to allocate the W^X memory used to create the thunk.
            #[allow(unused_variables)]
            pub fn try_with_cc_in<CC, F>(
                cconv: CC,
                fun: F,
                jit_alloc: A,
            ) -> Result<Self, JitAllocError>
            where
                F: ToBoxedUnsize<S>,
                (CC, F): $trait_ident<B>,
            {
                let storage = Box::into_raw(F::to_boxed_unsize(fun));

                // SAFETY:
                // - thunk_template pointer obtained from the correct source
                // - `closure` is a valid pointer to `fun`
                let thunk_info = unsafe {
                    create_thunk(<(CC, F)>::$thunk_template, storage as *const _, &jit_alloc)?
                };
                Ok(Self {
                    thunk_info,
                    jit_alloc,
                    storage,
                    phantom: PhantomData,
                })
            }

            /// Wraps `fun`, producing a bare function with calling convention `cconv`.
            ///
            /// Uses `jit_alloc` to allocate the W^X memory used to create the thunk.
            ///
            /// # Panics
            /// If the provided JIT allocator fails to allocate memory. For a non-panicking
            /// version, see
            #[doc = $try_with_cc_in_doc]
            #[allow(unused_variables)]
            #[inline]
            pub fn with_cc_in<CC, F>(cconv: CC, fun: F, jit_alloc: A) -> Self
            where
                F: ToBoxedUnsize<S>,
                (CC, F): $trait_ident<B>,
            {
                Self::try_with_cc_in(cconv, fun, jit_alloc).unwrap()
            }

            /// Wraps `fun`, producing a bare function with signature `B`.
            ///
            /// Uses `jit_alloc` to allocate the W^X memory used to create the thunk.
            ///
            /// This constructor is best used when the type of `B` is already known from an existing
            /// type annotation. If you want to infer `B` from the closure arguments and a calling
            /// convention, consider using
            #[doc = $with_cc_in_doc]
            /// instead.
            ///
            /// # Panics
            /// If the provided JIT allocator fails to allocate memory. For a non-panicking
            /// version, see
            #[doc = $try_with_cc_in_doc]
            #[inline]
            pub fn new_in<F>(fun: F, jit_alloc: A) -> Self
            where
                F: ToBoxedUnsize<S>,
                (B::CC, F): $trait_ident<B>,
            {
                Self::with_cc_in(B::CC::default(), fun, jit_alloc)
            }

            cc_shorthand_in!(new_c_in, $trait_ident, cc::C, "C");

            cc_shorthand_in!(new_system_in, $trait_ident, cc::System, "system");

            cc_shorthand_in!(
                new_sysv64_in,
                $trait_ident,
                cc::Sysv64,
                "sysv64",
                all(not(windows), target_arch = "x86_64")
            );

            cc_shorthand_in!(
                new_aapcs_in,
                $trait_ident,
                cc::Aapcs,
                "aapcs",
                any(doc, target_arch = "arm")
            );

            cc_shorthand_in!(
                new_fastcall_in,
                $trait_ident,
                cc::Fastcall,
                "fastcall",
                all(windows, any(target_arch = "x86_64", target_arch = "x86"))
            );

            cc_shorthand_in!(
                new_stdcall_in,
                $trait_ident,
                cc::Stdcall,
                "stdcall",
                all(windows, any(target_arch = "x86_64", target_arch = "x86"))
            );

            cc_shorthand_in!(
                new_cdecl_in,
                $trait_ident,
                cc::Cdecl,
                "cdecl",
                all(windows, any(target_arch = "x86_64", target_arch = "x86"))
            );

            cc_shorthand_in!(
                new_thiscall_in,
                $trait_ident,
                cc::Thiscall,
                "thiscall",
                all(windows, target_arch = "x86")
            );

            cc_shorthand_in!(
                new_win64_in,
                $trait_ident,
                cc::Win64,
                "win64",
                all(windows, target_arch = "x86_64")
            );

            #[$bare_toggle]
            /// Return a bare function pointer that invokes the underlying closure.
            ///
            /// # Safety
            /// While this method is safe, the returned function pointer is not. In particular, it
            /// must not be called when:
            /// - The lifetime of `self` has expired, or `self` has been dropped.
            #[doc = $safety_doc]
            #[inline]
            pub fn bare(self: $bare_receiver) -> B {
                // SAFETY: B is a bare function pointer
                unsafe { core::mem::transmute_copy(&self.thunk_info.thunk) }
            }

            /// Leak the underlying closure, returning the unsafe bare function pointer that invokes
            /// it.
            ///
            /// `self` must be `'static` for this method to be called.
            ///
            /// # Safety
            /// While this method is safe, the returned function pointer is not. In particular, it
            /// must not be called when:
            #[doc = $safety_doc]
            #[inline]
            pub fn leak(self) -> B
            where
                Self: 'static,
            {
                let no_drop = ManuallyDrop::new(self);
                // SAFETY: B is a bare function pointer
                unsafe { core::mem::transmute_copy(&no_drop.thunk_info.thunk) }
            }
        }

        impl<B: FnPtr, S: ?Sized, A: JitAlloc> Drop for $ty_name<B, S, A> {
            fn drop(&mut self) {
                // Don't panic on allocator failures for safety reasons
                // SAFETY:
                // - The caller of `bare()` promised not to call through the thunk after
                // the lifetime of self expires
                // - alloc_base is RX memory previously allocated by jit_alloc which has not been
                // freed yet
                unsafe { self.jit_alloc.release(self.thunk_info.alloc_base).ok() };

                // Free the closure
                // SAFETY:
                // - The caller of `bare()` promised not to call through the thunk after
                // the lifetime of self expires, so no borrow on closure exists
                drop(unsafe { Box::from_raw(self.storage) })
            }
        }

        #[cfg(any(feature = "bundled_jit_alloc", feature = "custom_jit_alloc"))]
        impl<B: FnPtr, S: ?Sized> $ty_name<B, S, GlobalJitAlloc> {
            /// Wraps `fun`, producing a bare function of signature `B`.
            ///
            /// This constructor is best used when the type of `B` is already known from an existing
            /// type annotation. If you want to infer `B` from the closure arguments and a calling
            /// convention, consider using
            #[doc = $with_cc_doc]
            /// or the `new_*` suffixed constructors instead.
            ///
            /// The W^X memory required is allocated using the global JIT allocator.
            #[inline]
            pub fn new<F>(fun: F) -> Self
            where
                F: ToBoxedUnsize<S>,
                (B::CC, F): $trait_ident<B>,
            {
                Self::new_in(fun, Default::default())
            }

            /// Wraps `fun`, producing a bare function with calling convention `cconv`.
            ///
            /// The W^X memory required is allocated using the global JIT allocator.
            #[inline]
            pub fn with_cc<CC, F>(cconv: CC, fun: F) -> Self
            where
                F: ToBoxedUnsize<S>,
                (CC, F): $trait_ident<B>,
            {
                Self::with_cc_in(cconv, fun, Default::default())
            }

            cc_shorthand!(new_c, $trait_ident, cc::C, "C");

            cc_shorthand!(new_system, $trait_ident, cc::System, "system");

            cc_shorthand!(
                new_sysv64,
                $trait_ident,
                cc::Sysv64,
                "sysv64",
                all(not(windows), target_arch = "x86_64")
            );

            cc_shorthand!(
                new_aapcs,
                $trait_ident,
                cc::Aapcs,
                "aapcs",
                any(doc, target_arch = "arm")
            );

            cc_shorthand!(
                new_fastcall,
                $trait_ident,
                cc::Fastcall,
                "fastcall",
                all(windows, any(target_arch = "x86_64", target_arch = "x86"))
            );

            cc_shorthand!(
                new_stdcall,
                $trait_ident,
                cc::Stdcall,
                "stdcall",
                all(windows, any(target_arch = "x86_64", target_arch = "x86"))
            );

            cc_shorthand!(
                new_cdecl,
                $trait_ident,
                cc::Cdecl,
                "cdecl",
                all(windows, any(target_arch = "x86_64", target_arch = "x86"))
            );

            cc_shorthand!(
                new_thiscall,
                $trait_ident,
                cc::Thiscall,
                "thiscall",
                all(windows, target_arch = "x86")
            );

            cc_shorthand!(
                new_win64,
                $trait_ident,
                cc::Win64,
                "win64",
                all(windows, target_arch = "x86_64")
            );
        }

        #[cfg(any(feature = "bundled_jit_alloc", feature = "custom_jit_alloc"))]
        /// Wrapper around a
        #[doc = $fn_trait_doc]
        /// closure which exposes a bare function thunk that can invoke it without
        /// additional arguments.
        ///
        /// This is a type alias only. Additional details and methods are described on the
        #[doc = $ty_name_doc]
        /// type.
        pub type $non_send_alias<'a, B, A = GlobalJitAlloc> = $ty_name<B, dyn Any + 'a, A>;

        #[cfg(not(any(feature = "bundled_jit_alloc", feature = "custom_jit_alloc")))]
        /// Wrapper around a
        #[doc = $fn_trait_doc]
        /// closure which exposes a bare function thunk that can invoke it without
        /// additional arguments.
        ///
        /// This is a type alias only. Additional details and methods are described on the
        #[doc = $ty_name_doc]
        /// type.
        pub type $non_send_alias<'a, B, A> = $ty_name<B, dyn Any + 'a, A>;

        #[cfg(any(feature = "bundled_jit_alloc", feature = "custom_jit_alloc"))]
        /// Wrapper around a `Send`
        #[doc = $fn_trait_doc]
        /// closure which exposes a bare function thunk that can invoke it without
        /// additional arguments.
        ///
        /// This is a type alias only. Additional details and methods are described on the
        #[doc = $ty_name_doc]
        /// type.
        pub type $send_alias<'a, B, A = GlobalJitAlloc> = $ty_name<B, dyn Send + 'a, A>;

        #[cfg(not(any(feature = "bundled_jit_alloc", feature = "custom_jit_alloc")))]
        /// Wrapper around a `Send`
        #[doc = $fn_trait_doc]
        /// closure which exposes a bare function thunk that can invoke it without
        /// additional arguments.
        ///
        /// This is a type alias only. Additional details and methods are described on the
        #[doc = $ty_name_doc]
        /// type.
        pub type $send_alias<'a, B, A> = $ty_name<B, dyn Send + 'a, A>;
    };
}

// TODO:
// BareFnOnce still needs work.
// In particular, to avoid leaks we need to have the compiler generated thunk
// call `release` on the allocator after it's done running, then drop the allocator.
// Then, to avoid double frees we need `bare` to be taken by value.
//
// At the moment, we simply force leaking for `BareFnOnce` by omitting `bare()`.

bare_closure_impl!(
    ty_name: BareFnOnceAny,
    non_send_alias: BareFnOnce,
    send_alias: BareFnOnceSend,
    trait_ident: FnOnceThunk,
    thunk_template: THUNK_TEMPLATE_ONCE,
    bare_toggle: cfg(any()),
    bare_receiver: Self,
    fn_trait_doc: "[`FnOnce`]",
    ty_name_doc: "[`BareFnOnceAny`]",
    with_cc_doc: "[`with_cc`](BareFnOnceAny::with_cc)",
    with_cc_in_doc: "[`with_cc_in`](BareFnOnceAny::with_cc_in)",
    try_with_cc_in_doc: "[`try_with_cc_in`](BareFnOnceAny::try_with_cc_in)",
    non_send_alias_doc: "[`BareFnOnce`]",
    send_alias_doc: "[`BareFnOnceSend`]",
    safety_doc: "- The function has been called before.\n
- The closure is not `Send`, if calling from a different thread than the current one."
);

bare_closure_impl!(
    ty_name: BareFnMutAny,
    non_send_alias: BareFnMut,
    send_alias: BareFnMutSend,
    trait_ident: FnMutThunk,
    thunk_template: THUNK_TEMPLATE_MUT,
    bare_toggle: cfg(all()),
    bare_receiver: &Self,
    fn_trait_doc: "[`FnMut`]",
    ty_name_doc: "[`BareFnMutAny`]",
    with_cc_doc: "[`with_cc`](BareFnMutAny::with_cc)",
    with_cc_in_doc: "[`with_cc_in`](BareFnMutAny::with_cc_in)",
    try_with_cc_in_doc: "[`try_with_cc_in`](BareFnMutAny::try_with_cc_in)",
    non_send_alias_doc:  "[`BareFnMut`]",
    send_alias_doc: "[`BareFnMutSend`]",
    safety_doc: "- A borrow induced by a previous call is still active.\n
- The closure is not `Sync`, if calling from a different thread than the current one."
);
bare_closure_impl!(
    ty_name: BareFnAny,
    non_send_alias: BareFn,
    send_alias: BareFnSend,
    trait_ident: FnThunk,
    thunk_template: THUNK_TEMPLATE,
    bare_toggle: cfg(all()),
    bare_receiver: &Self,
    fn_trait_doc: "[`Fn`]",
    ty_name_doc: "[`BareFnAny`]",
    with_cc_doc: "[`with_cc`](BareFnAny::with_cc)",
    with_cc_in_doc: "[`with_cc_in`](BareFnAny::with_cc_in)",
    try_with_cc_in_doc: "[`try_with_cc_in`](BareFnAny::try_with_cc_in)",
    non_send_alias_doc:  "[`BareFn`]",
    send_alias_doc: "[`BareFnSend`]",
    safety_doc: "- The closure is not `Sync`, if calling from a different thread than the current one."
);
